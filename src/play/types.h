/*
 * Wodox reimplemented again.
 * This code copyright (c) Luis Javier Sanz 2009-2013 
 */

#pragma once

#include "../core/list.h"
#include "../media/draw.h"


#include <unistd.h>		// For rand
#include <math.h>		// For hypot
#include <errno.h>
#include <stdint.h>

/* 
 * These define object flags.
 */
enum {
    SPRITE		= 0x0f,	// Mask for the sprite.
    VISIBLE		= 0x10,	// If visible, there must be a sprite.
    SOLID		= 0x20,	// Prevents objects from entering its space.
    HEAVY		= 0x40,	// Affected by forces.
    ACTIVE		= 0x80,	// Generates a signal.
};

/*
 * These define object types.
 */
enum {
    EMPTY	=  (0x0),
    GHOST	=  (0x0 | SOLID),
    GROUND	=  (0x0 | VISIBLE | SOLID),
    CRATE	=  (0x1 | SOLID | HEAVY),
    PLAYER	=  (0x2 | SOLID | HEAVY),
    SMALL	=  (0x3 | HEAVY),
    BELT_LF_0	=  (0x4 | VISIBLE | SOLID),
    BELT_LF_1	=  (0x4 | VISIBLE | SOLID | ACTIVE),
    BELT_BK_0	=  (0x5 | VISIBLE | SOLID),
    BELT_BK_1	=  (0x5 | VISIBLE | SOLID | ACTIVE),
    BELT_RT_0	=  (0x6 | VISIBLE | SOLID),
    BELT_RT_1	=  (0x6 | VISIBLE | SOLID | ACTIVE),
    BELT_FT_0	=  (0x7 | VISIBLE | SOLID),
    BELT_FT_1	=  (0x7 | VISIBLE | SOLID | ACTIVE),
    MOVING_0	=  (0x8 | SOLID),
    MOVING_1	=  (0x8 | SOLID | ACTIVE),
    BUTTON_0	=  (0x9 | VISIBLE | SOLID),
    BUTTON_1	=  (0x9 | VISIBLE | SOLID | ACTIVE),
    SWITCH_0	=  (0xa | VISIBLE | SOLID),
    SWITCH_1	=  (0xb | VISIBLE | SOLID | ACTIVE),
};

/*
 * These define object movement.
 */
enum {
    STILL		= 0,	// Not moving.
    DIR_DN		= 1,	// Moving down.
    DIR_UP		= 2,	// Moving up.
    DIR_LF		= 3,	// Moving left.
    DIR_RT		= 4,	// Moving right.
    DIR_BK		= 5,	// Moving back.
    DIR_FT		= 6,	// Moving front.
    WARP		= 7,	// Warping outside the level.
};

/*
 * These define the displacement and bounds to operate on raw data.
 */
static const Sint16 offset[] =
    { 0, -SIZE_2, SIZE_2, -SIZE, SIZE, -1, 1, 0 };
static const Uint16 bounds[] =
    { 0, SIZE_3, SIZE_3, SIZE_2, SIZE_2, SIZE, SIZE, 0 };

/*
 * Some more things...
 */
#define PUSH_DELAY 1		// Number of frames before the wodox can push another object.
#define OBJECT_POOL_SIZE 1000	// Number of allocated objects.
#define STATE_STACK_LEN 10	// Size of the "undo" stack.
#define RECORD_MOVE_LIST_SIZE 10000
				// Number of moves that may be remembered to replay a level (unimplemented). 


/*
 * Objects are movable and have states. The player, the crates, moving blocks,
 * etc. are objects. They are indexed in a grid to easily locate them in the
 * scene and as a double linked list to easily iterate over them.
 */
struct object {
    struct object *next;	// Next in list
    Uint8 type;			// Type of object.
    Uint16 off;			// Position.
    Uint8 dir;			// Direction of movement.
    Uint8 dsp;			// How many steps has the object moved between spaces.
};

/*
 * Static circuits connect buttons to positions on the map.
 */
struct static_circuit {
    struct static_circuit *next;// Next in list
    Uint16 size;		// Size of the tree.
    Uint16 *tree;		// Boolean operation.
    Uint16 off;			// Position.
};

/*
 * Dynamic circuits connect buttons to objects.
 */
struct dynamic_circuit {
    struct dynamic_circuit *next;// Next in list
    Uint16 size;		// Size of the tree.
    Uint16 *tree;		// Boolean operation.
    struct object *obj;		// Object.
};

/*
 * The level records are basically pairs <time,key>.
 */
struct record {
    Uint32 time;		// When the key was pushed.
    Sint8 key;			// Whick key.
};

/*
 * The scene is represented by all the following.
 *
 * First we have the objects. They are allocated in a "pool" that has space
 * enough for all of them and indexed in two doubly-linked lists. When a new
 * object is needed it is traken from the unused object list and inserted in
 * the used object list.
 *
 * The static map defines properties for each space. The name is misleading 
 * because object movement causes changes in the spaces they occupy. 
 *
 * The forces map defines where should dynamic objects in each space move. 
 * Note that there are forces not defined in this map, specifically those 
 * generated by conveyor belts.
 *
 * The object map holds pointers to the objects occupying each world position
 * for those spaces that hold one. This one is exactly what it says in the 
 * tin.
 *
 * These four are grouped in a structure called a state. This state can be
 * easily copied to make a snapshot of what the level was in an arbitrary point
 * in time.
 *
 * The state contains also a number of other control variables that handle
 * time, the state of the player object and the solution recording.
 */
struct state {
    struct object *objects;	// Objects in use.

    Uint8 static_map[SIZE][SIZE][SIZE];	// Static map.
    Uint8 forces_map[SIZE][SIZE][SIZE];	// Forces map.
    struct object *object_map[SIZE][SIZE][SIZE];	// Object map.

    Uint32 ticks;		// Number of iterations since the level began.
    struct record *record_ptr;	// The current record.

    Sint8 pushing;		// If the wodox is attempting to push something.
    Sint8 dst_ang;		// Target angle for the wodox.
    Sint8 cur_ang;		// Current angle for the wodox.

    struct object *outside;	// Small object swapping places with the wodox.
    struct object *inside;	// Small object inside the wodox.
    int unlocked;		// Determines if small objects inside the wodox move with it.
};

/*
 * And now... the game itself. 
 *
 * The keyxx and keepxx variables are control for the user input and main
 * loops. They can be reset in the most unsuspecting places, hence their
 * "globality".
 *
 * Apart from the state, the level contains some data that is not altered while
 * playing: the player object is always the same and the circuits that
 * determine the status of static and dynamic machines can not be modified
 * inside a level.
 *
 * The state stack allows quick saving and loading of a number of previous
 * states. It is a circular stack and all operations are performed on the top
 * element, meaning that saving more than the stack size overwrites old save
 * states.
 * 
 * TODO: Up to ten thousand moves may be recorded per level. Until now, this
 * only gave problems with specially dense people playing the 40th. 
 */
struct game {
    int keyup;			// Key for movng up.
    int keydn;			// Key for movng down.
    int keylf;			// Key for movng left.
    int keyrt;			// Key for movng right.

    int keep_going;		// While true, reload level.
    int keep_playing;		// While true, play level.
    int must_save;		// Important.
    int warped;			// True if the player has warped.
    int replay;			// True if we are automatically replaying the level.

    struct object *po;		// Player controlled object.

    struct static_circuit *static_circuits;	// Static circuits.
    struct dynamic_circuit *dynamic_circuits;	// Dynamic circuits.

    struct state cs;		// Current state.

    struct state state_stack[STATE_STACK_LEN];	// Saved states.
    struct state *state_stack_top;	// In a circular stack.
    struct state *state_stack_bottom;	// That may not be full.

    struct record record_list[RECORD_MOVE_LIST_SIZE];	// What the player has been doing.
};

/*
 * There can be only one!
 */
extern struct game game;

/*
 * Aliases for quick iteration on all elements and low level manipulation.
 */
#define MAP ((Uint8 *)game.cs.static_map)
#define FRC ((Uint8 *)game.cs.forces_map)
#define OBJ ((struct object **)game.cs.object_map)

/*
 * Offsets by direction.
 */
#define OFF_DN (-SIZE_2)
#define OFF_UP (SIZE_2)
#define OFF_LF (-SIZE)
#define OFF_RT (SIZE)
#define OFF_BK (-1)
#define OFF_FT (1)

/*
 * Macros to access the static map around an object.
 */
#define MAP_AT(__o) (MAP[(__o)->off])
#define MAP_NEXT(__o,__off) (MAP[(__o)->off + (__off)])

#define MAP_DN(__o) MAP_NEXT(__o,OFF_DN)
#define MAP_UP(__o) MAP_NEXT(__o,OFF_UP)
#define MAP_LF(__o) MAP_NEXT(__o,OFF_LF)
#define MAP_RT(__o) MAP_NEXT(__o,OFF_RT)
#define MAP_BK(__o) MAP_NEXT(__o,OFF_BK)
#define MAP_FT(__o) MAP_NEXT(__o,OFF_FT)

/*
 * Macros to access the object map around an object.
 */
#define OBJ_AT(__o) (OBJ[(__o)->off])
#define OBJ_NEXT(__o,__off) (OBJ[(__o)->off + (__off)])

#define OBJ_DN(__o) OBJ_NEXT(__o,OFF_DN)
#define OBJ_UP(__o) OBJ_NEXT(__o,OFF_UP)
#define OBJ_LF(__o) OBJ_NEXT(__o,OFF_LF)
#define OBJ_RT(__o) OBJ_NEXT(__o,OFF_RT)
#define OBJ_BK(__o) OBJ_NEXT(__o,OFF_BK)
#define OBJ_FT(__o) OBJ_NEXT(__o,OFF_FT)

/*
 * Macros to access the forces map around an object.
 */
#define FRC_AT(__o) (FRC[(__o)->off])
#define FRC_NEXT(__o,__off) (FRC[(__o)->off + (__off)])

#define FRC_DN(__o) FRC_NEXT(__o,OFF_DN)
#define FRC_UP(__o) FRC_NEXT(__o,OFF_UP)
#define FRC_LF(__o) FRC_NEXT(__o,OFF_LF)
#define FRC_RT(__o) FRC_NEXT(__o,OFF_RT)
#define FRC_BK(__o) FRC_NEXT(__o,OFF_BK)
#define FRC_FT(__o) FRC_NEXT(__o,OFF_FT)

/*
 * Macros to move objects.
 */
#define MOVE(__o,__dir,__off) ( \
  (__o)->dir = __dir, \
  MAP_NEXT(__o,__off) = (__o)->type, \
  MAP_AT(__o) = GHOST, \
  OBJ_NEXT(__o,__off) = (__o), \
  OBJ_AT(__o) = NULL)

#define MOVE_DN(__o) MOVE(__o, DIR_DN, OFF_DN)
#define MOVE_UP(__o) MOVE(__o, DIR_UP, OFF_UP)
#define MOVE_LF(__o) MOVE(__o, DIR_LF, OFF_LF)
#define MOVE_RT(__o) MOVE(__o, DIR_RT, OFF_RT)
#define MOVE_BK(__o) MOVE(__o, DIR_BK, OFF_BK)
#define MOVE_FT(__o) MOVE(__o, DIR_FT, OFF_FT)

/*
 * Macros to attempt to move objects.
 */
#define TRY_MOVE(__o,__dir,__off) ( \
  (MAP_NEXT(__o,__off) & SOLID) \
    ? STILL \
    : (MOVE(__o,__dir,__off), __dir))

#define TRY_MOVE_DN(__o) TRY_MOVE(__o, DIR_DN, OFF_DN)
#define TRY_MOVE_UP(__o) TRY_MOVE(__o, DIR_UP, OFF_UP)
#define TRY_MOVE_LF(__o) TRY_MOVE(__o, DIR_LF, OFF_LF)
#define TRY_MOVE_RT(__o) TRY_MOVE(__o, DIR_RT, OFF_RT)
#define TRY_MOVE_BK(__o) TRY_MOVE(__o, DIR_BK, OFF_BK)
#define TRY_MOVE_FT(__o) TRY_MOVE(__o, DIR_FT, OFF_FT)

/*
 * This macro moves the player in one direction. 
 */
#define TRY_MOVE_PLAYER(__dir,__off) \
do \
  { \
    struct object * __o; \
    if ((__o = OBJ_NEXT(game.po,__off)) && __o->dir == STILL) \
      { \
        if (__o->type == SMALL) \
	  { \
            if (game.cs.unlocked) \
	      { \
                game.cs.outside = __o; \
	        /*object_remove (game.cs.outside);*/ \
	      } \
          } \
        else if ((__o->type & HEAVY) && (__o->off / bounds[__dir] == (__o->off + __off) / bounds[__dir])) \
          { \
            if (game.cs.pushing++ > PUSH_DELAY && TRY_MOVE (__o, __dir, __off)) \
	      {  \
	        MOVE (game.po, __dir, __off);  \
	        game.cs.pushing = 0; \
	      } \
	    break; \
          } \
      } \
    if (TRY_MOVE (game.po, __dir, __off) && game.cs.unlocked) \
      { \
        if (game.cs.inside) \
          { \
            /*object_insert (game.cs.inside);*/ \
   	    game.cs.inside = NULL; \
          } \
        if (game.cs.outside) \
          { \
            game.cs.inside = game.cs.outside; \
            game.cs.outside = NULL; \
          } \
      } \
    else if (game.cs.outside)\
      { \
        /*object_insert (game.cs.outside);*/ \
      } \
    game.cs.pushing = 0; \
  } \
while (0)

/*
 * To pick or release an item.
 */
#define PICK_OR_RELEASE() \
do \
  { \
    if (game.cs.inside && game.po->dir == STILL)  \
      { \
        if (game.cs.unlocked) \
          { \
	    release_buttons (game.cs.inside); \
	    game.cs.unlocked = 0; \
	  } \
	else \
          { \
	    game.cs.inside->off = game.po->off; \
	    press_buttons (game.cs.inside); \
	    game.cs.unlocked = 1; \
	  } \
      } \
  } \
while (0)

/*
 * To record a key pressing.
 */
#define RECORD_MOVE(k) \
do \
  { \
    if (game.cs.record_ptr - game.record_list < RECORD_MOVE_LIST_SIZE) \
      { \
        game.cs.record_ptr->time = game.cs.ticks; \
        game.cs.record_ptr->key = k; \
        ++game.cs.record_ptr; \
      } \
    game.replay = 0; \
  } \
while (0)

/*
 * Each sound plays through a channel.
 */
#define CHANNEL_WODOX	1
#define CHANNEL_OPEN	2
#define CHANNEL_PRESS	3
#define CHANNEL_RELEASE	4

extern SDL_Surface *surface_levelname;
