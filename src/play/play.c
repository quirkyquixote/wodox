/*
t * Wodox reimplemented again.
 * This code copyright (c) Luis Javier Sanz 2009 
 */

#include "play.h"
#include "../core/list.h"

#include <unistd.h>		// For rand
#include <math.h>		// For hypot
#include <errno.h>

/* 
 * These define object flags.
 */
#define SPRITE		0x0f	// Mask for the sprite.
#define VISIBLE		0x10	// If visible, there must be a sprite.
#define SOLID		0x20	// Prevents objects from entering its space.
#define HEAVY		0x40	// Affected by forces.
#define ACTIVE		0x80	// Generates a signal.

/*
 * These define object types.
 */
#define EMPTY		0x00	// (0x0)
#define GHOST		0x20	// (0x0 | SOLID)
#define GROUND		0x30	// (0x0 | VISIBLE | SOLID)
#define CRATE		0x61	// (0x1 | SOLID | HEAVY)
#define PLAYER		0x62	// (0x2 | SOLID | HEAVY)
#define SMALL		0x43	// (0x3 | HEAVY)
#define BELT_LF_0	0x34	// (0x4 | VISIBLE | SOLID)
#define BELT_LF_1	0xb4	// (0x4 | VISIBLE | SOLID | ACTIVE)
#define BELT_BK_0	0x35	// (0x5 | VISIBLE | SOLID)
#define BELT_BK_1	0xb5	// (0x5 | VISIBLE | SOLID | ACTIVE)
#define BELT_RT_0	0x36	// (0x6 | VISIBLE | SOLID)
#define BELT_RT_1	0xb6	// (0x6 | VISIBLE | SOLID | ACTIVE)
#define BELT_FT_0	0x37	// (0x7 | VISIBLE | SOLID)
#define BELT_FT_1	0xb7	// (0x7 | VISIBLE | SOLID | ACTIVE)
#define MOVING_0	0x28	// (0x8 | SOLID)
#define MOVING_1	0xa8	// (0x8 | SOLID | ACTIVE)
#define BUTTON_0	0x39	// (0x9 | VISIBLE | SOLID)
#define BUTTON_1	0xb9	// (0x9 | VISIBLE | SOLID | ACTIVE)
#define SWITCH_0	0x3a	// (0xa | VISIBLE | SOLID)
#define SWITCH_1	0xbb	// (0xb | VISIBLE | SOLID | ACTIVE)

/*
 * These define object movement.
 */
#define STILL		0	// Not moving. 
#define DIR_DN		1	// Moving down.
#define DIR_UP		2	// Moving up.
#define DIR_LF		3	// Moving left.
#define DIR_RT		4	// Moving right.
#define DIR_BK		5	// Moving back.
#define DIR_FT		6	// Moving front.
#define WARP		7	// Warping outside the level.

/*
 * These define the displacement and bounds to operate on raw data.
 */
static const Sint16 offset[] = { 0, -SIZE_2, SIZE_2, -SIZE, SIZE, -1, 1, 0 };
static const Uint16 bounds[] = { 0, SIZE_3, SIZE_3, SIZE_2, SIZE_2, SIZE, SIZE, 0 };

/*
 * Some more things...
 */
#define PUSH_DELAY 1 		// Number of frames before the wodox can push another object.
#define OBJECT_POOL_SIZE 1000	// Number of allocated objects.
#define STATE_STACK_LEN 10	// Size of the "undo" stack.
#define RECORD_MOVE_LIST_SIZE 10000	
				// Number of moves that may be remembered to replay a level (unimplemented). 


/*
 * Objects are movable and have states. The player, the crates, moving blocks,
 * etc. are objects. They are indexed in a grid to easily locate them in the
 * scene and as a double linked list to easily iterate over them.
 */
struct object 
{
  list_node		node;	// Previous and nest objects.
  Uint8			type;	// Type of object.
  Uint16		off;	// Position.
  Uint8			dir;	// Direction of movement.
  Uint8			dsp;	// How many steps has the object moved between spaces.
};

/*
 * Static circuits connect buttons to positions on the map.
 */
struct static_circuit
{
  list_node		node;	// Previous and next objects.
  Uint16		size;	// Size of the tree.
  Uint16 *		tree;	// Boolean operation.
  Uint16 		off;	// Position.
};

/*
 * Dynamic circuits connect buttons to objects.
 */
struct dynamic_circuit
{
  list_node		node;	// Previous and next objects.
  Uint16		size;	// Size of the tree.
  Uint16 *		tree;	// Boolean operation.
  struct object * 	obj;	// Object.
};

/*
 * The level records are basically pairs <time,key>.
 */
struct record
{
  Uint32 time;			// When the key was pushed.
  Sint8 key;			// Whick key.
};

/*
 * The scene is represented by all the following.
 *
 * First we have the objects. They are allocated in a "pool" that has space
 * enough for all of them and indexed in two doubly-linked lists. When a new
 * object is needed it is traken from the unused object list and inserted in
 * the used object list.
 *
 * The static map defines properties for each space. The name is misleading 
 * because object movement causes changes in the spaces they occupy. 
 *
 * The forces map defines where should dynamic objects in each space move. 
 * Note that there are forces not defined in this map, specifically those 
 * generated by conveyor belts.
 *
 * The object map holds pointers to the objects occupying each world position
 * for those spaces that hold one. This one is exactly what it says in the 
 * tin.
 *
 * These four are grouped in a structure called a state. This state can be
 * easily copied to make a snapshot of what the level was in an arbitrary point
 * in time.
 *
 * The state contains also a number of other control variables that handle
 * time, the state of the player object and the solution recording.
 */
struct state
{
  struct object		object_pool[OBJECT_POOL_SIZE];	// All objects allocated here.
  list			unused_objects;		// Objects not created.
  list			objects;		// Objects in use.

  Uint8			static_map[SIZE][SIZE][SIZE];	// Static map.
  Uint8			forces_map[SIZE][SIZE][SIZE];	// Forces map.
  struct object *	object_map[SIZE][SIZE][SIZE];	// Object map.

  Uint32		ticks;		// Number of iterations since the level began.
  struct record *	record_ptr;	// The current record.

  Sint8			pushing;	// If the wodox is attempting to push something.
  Sint8			dst_ang;	// Target angle for the wodox.
  Sint8			cur_ang;	// Current angle for the wodox.

  struct object *	outside;	// Small object swapping places with the wodox.
  struct object *	inside;		// Small object inside the wodox.
  int			unlocked;	// Determines if small objects inside the wodox move with it.
};

/*
 * And now... the game itself. 
 *
 * The keyxx and keepxx variables are control for the user input and main
 * loops. They can be reset in the most unsuspecting places, hence their
 * "globality".
 *
 * Apart from the state, the level contains some data that is not altered while
 * playing: the player object is always the same and the circuits that
 * determine the status of static and dynamic machines can not be modified
 * inside a level.
 *
 * The state stack allows quick saving and loading of a number of previous
 * states. It is a circular stack and all operations are performed on the top
 * element, meaning that saving more than the stack size overwrites old save
 * states.
 * 
 * TODO: Up to ten thousand moves may be recorded per level. Until now, this
 * only gave problems with specially dense people playing the 40th. 
 */
struct game
{
  int 			keyup;		// Key for movng up.
  int 			keydn;		// Key for movng down.
  int 			keylf;		// Key for movng left.
  int 			keyrt;		// Key for movng right.

  int			keep_going;	// While true, reload level.
  int			keep_playing;	// While true, play level.
  int			must_save;	// Important.
  int			warped;		// True if the player has warped.
  int			replay;		// True if we are automatically replaying the level.

  struct object *	po;		// Player controlled object.

  list			static_circuits;	// Static circuits.
  list			dynamic_circuits;	// Dynamic circuits.

  struct state		cs;		// Current state.

  struct state		state_stack[STATE_STACK_LEN];	// Saved states.
  struct state *	state_stack_top;		// In a circular stack.
  struct state *	state_stack_bottom;		// That may not be full.

  struct record		record_list[RECORD_MOVE_LIST_SIZE];	// What the player has been doing.
};

/*
 * There can be only one!
 */
static struct game game;

/*
 * This is used to draw a random screen transition.
 */
typedef void transition_function (Sint32 x, Sint32 y, int k);

/*
 * All static functions declared here.
 */
static int load_level (const char * path);
static void free_level ();
static void run_level ();

static void update_static_circuits ();
static void update_dynamic_circuits ();
static void update_heavy_objects ();
static void update_player_object ();
static void update_objects ();

static void draw_objects ();
static void draw_column (size_t i, size_t k);
static void draw_foreground ();

static void handle_player_input ();

static struct object * object_grab (Uint8 type, Uint16 off);
//static void object_drop (struct object * o);
static void object_insert (struct object * o);
static void object_remove (struct object * o);

static int levitate (struct object * o);

static void release_buttons (struct object * o);
static void press_buttons (struct object * o);

static int calculate (Uint16 * tree, size_t off);

static void save_state ();
static void load_state ();

static void transition0 (Sint32 x, Sint32 y, int k);
static void transition1 (Sint32 x, Sint32 y, int k);
static void transition2 (Sint32 x, Sint32 y, int k);

/*
 * Aliases for quick iteration on all elements and low level manipulation.
 */
#define MAP ((Uint8 *)game.cs.static_map)
#define FRC ((Uint8 *)game.cs.forces_map)
#define OBJ ((struct object **)game.cs.object_map)

/*
 * Offsets by direction.
 */
#define OFF_DN (-SIZE_2)
#define OFF_UP (SIZE_2)
#define OFF_LF (-SIZE)
#define OFF_RT (SIZE)
#define OFF_BK (-1)
#define OFF_FT (1)

/*
 * Macros to access the static map around an object.
 */
#define MAP_AT(__o) (MAP[(__o)->off])
#define MAP_NEXT(__o,__off) (MAP[(__o)->off + (__off)])

#define MAP_DN(__o) MAP_NEXT(__o,OFF_DN)
#define MAP_UP(__o) MAP_NEXT(__o,OFF_UP)
#define MAP_LF(__o) MAP_NEXT(__o,OFF_LF)
#define MAP_RT(__o) MAP_NEXT(__o,OFF_RT)
#define MAP_BK(__o) MAP_NEXT(__o,OFF_BK)
#define MAP_FT(__o) MAP_NEXT(__o,OFF_FT)

/*
 * Macros to access the object map around an object.
 */
#define OBJ_AT(__o) (OBJ[(__o)->off])
#define OBJ_NEXT(__o,__off) (OBJ[(__o)->off + (__off)])

#define OBJ_DN(__o) OBJ_NEXT(__o,OFF_DN)
#define OBJ_UP(__o) OBJ_NEXT(__o,OFF_UP)
#define OBJ_LF(__o) OBJ_NEXT(__o,OFF_LF)
#define OBJ_RT(__o) OBJ_NEXT(__o,OFF_RT)
#define OBJ_BK(__o) OBJ_NEXT(__o,OFF_BK)
#define OBJ_FT(__o) OBJ_NEXT(__o,OFF_FT)

/*
 * Macros to access the forces map around an object.
 */
#define FRC_AT(__o) (FRC[(__o)->off])
#define FRC_NEXT(__o,__off) (FRC[(__o)->off + (__off)])

#define FRC_DN(__o) FRC_NEXT(__o,OFF_DN)
#define FRC_UP(__o) FRC_NEXT(__o,OFF_UP)
#define FRC_LF(__o) FRC_NEXT(__o,OFF_LF)
#define FRC_RT(__o) FRC_NEXT(__o,OFF_RT)
#define FRC_BK(__o) FRC_NEXT(__o,OFF_BK)
#define FRC_FT(__o) FRC_NEXT(__o,OFF_FT)

/*
 * Macros to move objects.
 */
#define MOVE(__o,__dir,__off) ( \
  (__o)->dir = __dir, \
  MAP_NEXT(__o,__off) = (__o)->type, \
  MAP_AT(__o) = GHOST, \
  OBJ_NEXT(__o,__off) = (__o), \
  OBJ_AT(__o) = NULL) 

#define MOVE_DN(__o) MOVE(__o, DIR_DN, OFF_DN)
#define MOVE_UP(__o) MOVE(__o, DIR_UP, OFF_UP)
#define MOVE_LF(__o) MOVE(__o, DIR_LF, OFF_LF)
#define MOVE_RT(__o) MOVE(__o, DIR_RT, OFF_RT)
#define MOVE_BK(__o) MOVE(__o, DIR_BK, OFF_BK)
#define MOVE_FT(__o) MOVE(__o, DIR_FT, OFF_FT)

/*
 * Macros to attempt to move objects.
 */
#define TRY_MOVE(__o,__dir,__off) ( \
  (MAP_NEXT(__o,__off) & SOLID) \
    ? STILL \
    : (MOVE(__o,__dir,__off), __dir))

#define TRY_MOVE_DN(__o) TRY_MOVE(__o, DIR_DN, OFF_DN)
#define TRY_MOVE_UP(__o) TRY_MOVE(__o, DIR_UP, OFF_UP)
#define TRY_MOVE_LF(__o) TRY_MOVE(__o, DIR_LF, OFF_LF)
#define TRY_MOVE_RT(__o) TRY_MOVE(__o, DIR_RT, OFF_RT)
#define TRY_MOVE_BK(__o) TRY_MOVE(__o, DIR_BK, OFF_BK)
#define TRY_MOVE_FT(__o) TRY_MOVE(__o, DIR_FT, OFF_FT)

/*
 * This macro moves the player in one direction. 
 */
#define TRY_MOVE_PLAYER(__dir,__off) \
do \
  { \
    struct object * __o; \
    if ((__o = OBJ_NEXT(game.po,__off)) && __o->dir == STILL) \
      { \
        if (__o->type == SMALL) \
	  { \
            if (game.cs.unlocked) \
	      { \
                game.cs.outside = __o; \
	        object_remove (game.cs.outside); \
	      } \
          } \
        else if ((__o->type & HEAVY) && (__o->off / bounds[__dir] == (__o->off + __off) / bounds[__dir])) \
          { \
            if (game.cs.pushing++ > PUSH_DELAY && TRY_MOVE (__o, __dir, __off)) \
	      {  \
	        MOVE (game.po, __dir, __off);  \
	        game.cs.pushing = 0; \
	      } \
	    break; \
          } \
      } \
    if (TRY_MOVE (game.po, __dir, __off) && game.cs.unlocked) \
      { \
        if (game.cs.inside) \
          { \
            object_insert (game.cs.inside); \
   	    game.cs.inside = NULL; \
          } \
        if (game.cs.outside) \
          { \
            game.cs.inside = game.cs.outside; \
            game.cs.outside = NULL; \
          } \
      } \
    else if (game.cs.outside)\
      { \
        object_insert (game.cs.outside); \
      } \
    game.cs.pushing = 0; \
  } \
while (0)

/*
 * To pick or release an item.
 */
#define PICK_OR_RELEASE() \
do \
  { \
    if (game.cs.inside && game.po->dir == STILL)  \
      { \
        if (game.cs.unlocked) \
          { \
	    release_buttons (game.cs.inside); \
	    game.cs.unlocked = 0; \
	  } \
	else \
          { \
	    game.cs.inside->off = game.po->off; \
	    press_buttons (game.cs.inside); \
	    game.cs.unlocked = 1; \
	  } \
      } \
  } \
while (0)

/*
 * To record a key pressing.
 */
#define RECORD_MOVE(k) \
do \
  { \
    if (game.cs.record_ptr - game.record_list < RECORD_MOVE_LIST_SIZE) \
      { \
        game.cs.record_ptr->time = game.cs.ticks; \
        game.cs.record_ptr->key = k; \
        ++game.cs.record_ptr; \
      } \
    game.replay = 0; \
  } \
while (0)

/*
 * Each sound plays through a channel.
 */
#define CHANNEL_WODOX	1
#define CHANNEL_OPEN	2
#define CHANNEL_PRESS	3
#define CHANNEL_RELEASE	4

/*
 * A surface for the level name.
 */
static SDL_Surface * surface_levelname = NULL;

/*
 * Play a level.
 */
int
play (const char * path, const char * name)
{
  SDL_EnableKeyRepeat (0, SDL_DEFAULT_REPEAT_INTERVAL);
  surface_levelname = TTF_RenderUTF8_Blended (font_large, name, color_white);

  game.state_stack_top = game.state_stack;
  game.state_stack_bottom = game.state_stack;

  game.keep_playing = 1;

  while (game.keep_playing && load_level (path))
    {
      run_level ();
      free_level ();
    }
/*
  if (warped && load_level (path))
    {
       run_level (1, &warped);
       free_level ();
    }
*/
  SDL_FreeSurface (surface_levelname);
  SDL_EnableKeyRepeat (SDL_DEFAULT_REPEAT_DELAY, SDL_DEFAULT_REPEAT_INTERVAL);

  return game.warped;
}

/*
 * Load a level.
 */
int
load_level (const char * path)
{
  FILE * f;
  Uint16 i;
  int c;
  struct static_circuit * s;
  struct dynamic_circuit * d;
  list_node * it;

  if ((f = fopen (path, "r")) == NULL)
    {
      fprintf (stderr, "couldn't open %s; %s\n", path, strerror (errno));
      return 0;
    }

  // Clean up the current state.

  memset (game.cs.static_map, GROUND, sizeof (Uint8) * SIZE_3);
  memset (game.cs.forces_map, DIR_DN, sizeof (Uint8) * SIZE_3);
  memset (game.cs.object_map, 0, sizeof (struct object *) * SIZE_3);
  memset (game.cs.object_pool, 0, sizeof (struct object) * OBJECT_POOL_SIZE);

  list_clear (&game.cs.objects);
  list_clear (&game.cs.unused_objects);

  for (i = 0; i < OBJECT_POOL_SIZE; ++i)
    {
      list_push_back (&game.cs.unused_objects, (list_node *)(game.cs.object_pool + i));
    }

  list_clear (&game.static_circuits);
  list_clear (&game.dynamic_circuits);

  game.po = NULL;

  // Read all objects and set maps according to the piece in each space.

  for (i = 0; i < SIZE_3; ++i)
    switch ((c = fgetc (f)))
      {
      case  0: MAP[i] = EMPTY; break;
      case  1: MAP[i] = GROUND; FRC[i + OFF_UP] = STILL; break;
      case  2: object_insert (object_grab (CRATE, i)); break;
      case  3: object_insert ((game.po = object_grab (PLAYER, i))); break;
      case  4: object_insert (object_grab (SMALL, i)); break;
      case  5: MAP[i] = BELT_LF_1; FRC[i + OFF_UP] = STILL; break;
      case  6: MAP[i] = BELT_BK_1; FRC[i + OFF_UP] = STILL; break;
      case  7: MAP[i] = BELT_RT_1; FRC[i + OFF_UP] = STILL; break;
      case  8: MAP[i] = BELT_FT_1; FRC[i + OFF_UP] = STILL; break;
      case  9: object_insert (object_grab (MOVING_0, i)); break;
      case 10: MAP[i] = BUTTON_0; FRC[i + OFF_UP] = STILL; break;
      case 11: MAP[i] = SWITCH_0; FRC[i + OFF_UP] = STILL; break;
      case 12: MAP[i] = SWITCH_1; FRC[i + OFF_UP] = STILL; break;
      case 17: MAP[i] = EMPTY; FRC[i] = DIR_UP; FRC[i + OFF_UP] = STILL; break;
      case 18: MAP[i] = EMPTY; FRC[i] = WARP; break;

      case EOF:
        fprintf (stderr, "unexpected end of file in %s\n", path); 
	fclose (f);
	return 0;

      default:   
        fprintf (stderr, "unexpected object: %x at %u in %s\n", c, i, path); 
	fclose (f);
	return 0;
      }

  // A wodoxless level can still be executed, but we send a warning.

  if (game.po == NULL)
    {
      fprintf (stderr, "there is no wodox in %s\n", path);
    }

  // Read circuits. They will be static or dynamic depending on what kind of
  // piece has been previously loaded in the space they are pointing to.

  while (fread (&i, sizeof (Uint16), 1, f) == 1 && i < SIZE_3)
    {
      if (OBJ[i])
        {
	  d = (struct dynamic_circuit *)malloc (sizeof (struct dynamic_circuit));
	  d->obj = OBJ[i];
	  fread (&d->size, sizeof (Uint16), 1, f);
	  d->tree = (Uint16 *)malloc (sizeof (Uint16) * d->size);
	  fread (d->tree, sizeof (Uint16), d->size, f);
          list_push_back (&game.dynamic_circuits, &(d->node));
	}
      else
        {
          s = (struct static_circuit *)malloc (sizeof (struct static_circuit));
          s->off = i;
	  fread (&s->size, sizeof (Uint16), 1, f);
	  s->tree = (Uint16 *)malloc (sizeof (Uint16) * s->size);
          fread (s->tree, sizeof (Uint16), s->size, f);
          list_push_back (&game.static_circuits, &(s->node));
	}
    }

  fclose (f);

  // Buttons under objects are pressed.

  for (it = game.cs.objects.begin; it != game.cs.objects.end; it = it->next)
    {
      if ((struct object *)it != game.po)
        {
	  press_buttons ((struct object *)it);
	}
    }

  return 1;
}

/*
 * Setdown level.
 */
void 
free_level ()
{
  struct static_circuit * s;
  struct dynamic_circuit * d;

  while (!list_empty (&game.static_circuits))
    {
      s = (struct static_circuit *)game.static_circuits.begin;
      list_pop_front (&game.static_circuits);
      free (s->tree);
      free (s);
    }

  while (!list_empty (&game.dynamic_circuits))
    {
      d = (struct dynamic_circuit *)game.dynamic_circuits.begin;
      list_pop_front (&game.dynamic_circuits);
      free (d->tree);
      free (d);
    }
}

/*
 * To run a level. This is almost your garden variety main game loop,
 * delegating most of the work in other methods but in order to correctly
 * handle resources and flow when undoing movements while aborting the level
 * the normal flow is broken by a GOTO.
 */
void
run_level ()
{
  // SDL stuff.

  SDL_Event event;

  // Current game state.

  game.cs.pushing = 0;
  game.cs.dst_ang = 0;
  game.cs.cur_ang = 0;

  game.cs.outside = NULL;
  game.cs.inside = NULL;
  game.cs.unlocked = 1;

  game.cs.ticks = 0;
  game.cs.record_ptr = game.record_list;

  // If the state stack is empty, record the initial state.

  if (game.state_stack_top == game.state_stack_bottom)
    {
      save_state ();
    }

  // And here's the aberration. It is said that Djikstra headbangs his coffin
  // once per each one of those. I guess that he will do mine around year 2500
  // or so.

game_loop_begin:

  game.keyup = 0;
  game.keydn = 0;
  game.keylf = 0;
  game.keyrt = 0;

  game.keep_going = 1;
  game.must_save = 0;
  game.warped = 0;

  if (enable_audio)
    {
      Mix_PlayChannel (CHANNEL_WODOX, chunk_wodox, -1);
      Mix_Pause (CHANNEL_WODOX);
    }

  while (game.keep_going)
    {
      update_static_circuits ();	// Static circuits.
      update_dynamic_circuits ();	// Dynamic circuits.
      update_heavy_objects ();		// Gravity and other forces.
      update_player_object ();		// Push the wodox around.
      update_objects ();		// Generic object code.

      draw_background ();		// Background texture.
      draw_objects ();			// Draw all objects and features of the level.

      handle_player_input ();		// Handle events and more.

      draw_foreground ();		// Draw some GUI data. This is done
					// after the event handling because
					// these messages should not appear
					// when freezing the game.

      sync ();				// Update screen.

      ++game.cs.ticks;			// On to the next iteration.
    }

  if (enable_audio)
    {
      Mix_HaltChannel (CHANNEL_WODOX);
    }

  // Before terminating we perform a screen transition to close the level but
  // we must still check playr input to recognize some things. Pressing
  // BACKSPACE during transition returns the wodox to the last safe position.
  // Pushing ESCAPE will prevent the level from reloading and return to the
  // menu. Any other key will just stop the transition and restart the level.

  // Determine transition focus and function.
  
  Uint32 i, j, k;

  if (game.po)
    {
      i = SCREENX (SPS * X(game.po->off), SPS * Y(game.po->off), SPS * Z(game.po->off)) + 28;
      j = SCREENY (SPS * X(game.po->off), SPS * Y(game.po->off), SPS * Z(game.po->off)) + 32;
    }
  else
    {
      i = canvas->w / 2;
      j = canvas->h / 2;
    }

  transition_function * transition = NULL;

  switch ((int)(3 * (rand () / (RAND_MAX + 1.))))
    {
    case 0: transition = &transition0; break;
    case 1: transition = &transition1; break;
    case 2: transition = &transition2; break;
    }

  // Perform a transition.

  for (k = 0; k < 32; ++k)
    {
      if (SDL_PollEvent (&event))
	{
	  switch (event.type)
	    {
	    case SDL_KEYDOWN: 
	      switch (event.key.keysym.sym)
	        {
		case SDLK_BACKSPACE:	load_state (); goto game_loop_begin;
		case SDLK_ESCAPE:	game.keep_playing = 0; return;
		default:		return;
		}
	      break;
	    case SDL_QUIT: exit (0);
	    }
	}

      transition (i, j, k);
      sync ();
    }

  // Return.

  return;
}

/*
 * Check the state for all static circuits. These may activate and deactivate
 * levitators and conveyor belts.
 *
 * Levitators are a special case because when they are off the only clue to
 * their presence is the fact that there is a static circuit pointing an empty
 * space; thus activating or deactivating levitators is done when there is no
 * other machine in place.
 */
void
update_static_circuits ()
{
  list_node * it;
  struct static_circuit * s;

  for (it = game.static_circuits.begin; it != game.static_circuits.end; it = it->next)
    {
      s = (struct static_circuit *)it;

      if (calculate (s->tree, 0))
        {
          switch (MAP_AT (s))
            {
            case BELT_LF_0: MAP_AT (s) = BELT_LF_1; break;
            case BELT_RT_0: MAP_AT (s) = BELT_RT_1; break;
            case BELT_BK_0: MAP_AT (s) = BELT_BK_1; break;
            case BELT_FT_0: MAP_AT (s) = BELT_FT_1; break;

            case BELT_LF_1:
            case BELT_RT_1:
            case BELT_BK_1:
            case BELT_FT_1:
	      break;

            default:   
              FRC_AT (s) = DIR_UP; 
	      if (FRC_UP (s) == DIR_DN)
 	        { FRC_UP (s) = STILL; }
	      break;
           }
        }
      else
        {
          switch (MAP_AT (s))
            {
            case BELT_LF_1: MAP_AT (s) = BELT_LF_0; break;
            case BELT_RT_1: MAP_AT (s) = BELT_RT_0; break;
            case BELT_BK_1: MAP_AT (s) = BELT_BK_0; break;
            case BELT_FT_1: MAP_AT (s) = BELT_FT_0; break;

            case BELT_LF_0:
            case BELT_RT_0:
            case BELT_BK_0:
            case BELT_FT_0:
	      break;

            default:   
              FRC_AT (s) = (FRC_DN (s) == DIR_UP) ? STILL : DIR_DN;
     	      if (FRC_UP (s) == STILL)
 	        { FRC_UP (s) = DIR_DN; }
	      break;
            }
        }
    }
}

/*
 * Check state for all dynamic circuits. These may activate and deactivate
 * moving blocks.
 */
void
update_dynamic_circuits ()
{
  list_node * it;
  struct dynamic_circuit * d;

  for (it = game.dynamic_circuits.begin; it != game.dynamic_circuits.end; it = it->next)
    {
      d = (struct dynamic_circuit *)it;

      if (calculate (d->tree, 0))
        {
          switch (d->obj->type)
            {
            case MOVING_0: 
              if (TRY_MOVE_DN (d->obj))
	        {
    	          MAP_DN (d->obj) = MOVING_1;
		  d->obj->type = MOVING_1; 
		  if (enable_audio) { Mix_PlayChannel (CHANNEL_OPEN, chunk_open, 0); }
		}
	      break;
	    }
        }
      else
        {
          switch (d->obj->type)
            {
            case MOVING_1: 
              if (levitate (d->obj)) // Moving blocks are mightily strong.
		{ 
		  MAP_UP (d->obj) = MOVING_0;
		  d->obj->type = MOVING_0; 
		  if (enable_audio) { Mix_PlayChannel (CHANNEL_OPEN, chunk_open, 0); }
		}
	      break;
	    }
    	}
    }
}

/*
 * Heavy objects are subject to forces. Depending on the value of the space in
 * the forces map, they can go either up, down or nowhere, but if they ought to
 * go up and are unable to do so or the space has no force they might be
 * affected by a conveyor belt. For these checks we must iterate on the object
 * map because order matters: objects in higher layers have priority.
 */
void
update_heavy_objects ()
{
  size_t off;
  struct object * o;

  for (off = SIZE_3 - 1; off < SIZE_3; --off)
    {
      if ((o = OBJ[off]) && (o->type & HEAVY) && (o->dir == STILL))
	{
	  switch (FRC[off])
	    {
	    case DIR_DN: if (Y (o->off) > MIN) TRY_MOVE_DN (o); break;
	    case DIR_UP: if (levitate (o)) break; // Levitators are mightily strong.
	    }

      if (o->dir == STILL)
	{
	  switch (MAP[off - SIZE_2])
	    {	
	    case BELT_LF_1: if (X (o->off) > MIN) TRY_MOVE_LF (o); break;
            case BELT_RT_1: if (X (o->off) < MAX) TRY_MOVE_RT (o); break;
   	    case BELT_BK_1: if (Z (o->off) > MIN) TRY_MOVE_BK (o); break;
	    case BELT_FT_1: if (Z (o->off) < MAX) TRY_MOVE_FT (o); break;
	    }
        }
	}
    }
}

/*
 * Control for the player object.
 */
void
update_player_object ()
{
  // Handle wodox rotation. This is for purely decorative purposes.

  switch (game.cs.cur_ang - game.cs.dst_ang) 
    {
    case -8 ... -5: if (--game.cs.cur_ang < 0) game.cs.cur_ang = 7; break; 
    case -4 ... -1: ++game.cs.cur_ang; break; 
    case  1 ...  4: --game.cs.cur_ang; break; 
    case  5 ...  8: if (++game.cs.cur_ang > 7) game.cs.cur_ang = 0; break;
    default: game.cs.cur_ang = game.cs.dst_ang; break;
    } 

  // Handle player movement; In addition to being a heavy object, the 
  // player object:
  //
  //  - Can be moved by the player if there are no external forces.
  //  - When moving it can push other heavy objects.
  //  - It is affected by the 'warp force'.
  //  - It is 'killed' if it reaches the lowermost layer of the level.
  //  - It interacts in complex ways with small objects.
  //
  // I hate small objects.
      
  if (game.po && game.po->dir == STILL)
    { 
      if (Y (game.po->off) == 0)
	{
	  game.keep_going = 0;
	}

      if (FRC_AT (game.po) == WARP)
	{
	  game.keep_going = 0;
	  game.keep_playing = 0;
	  game.warped = 1;
	}

      switch (game.keydn - game.keyup)
	{
	case -1: game.cs.dst_ang = 0; if (X (game.po->off) > MIN) TRY_MOVE_PLAYER (DIR_LF, OFF_LF); break;
	case  1: game.cs.dst_ang = 4; if (X (game.po->off) < MAX) TRY_MOVE_PLAYER (DIR_RT, OFF_RT); break;

	default:
	  switch (game.keylf - game.keyrt)
	    {
	    case -1: game.cs.dst_ang = 2; if (Z (game.po->off) > MIN) TRY_MOVE_PLAYER (DIR_BK, OFF_BK); break;
	    case  1: game.cs.dst_ang = 6; if (Z (game.po->off) < MAX) TRY_MOVE_PLAYER (DIR_FT, OFF_FT); break;
	    default: game.cs.pushing = 0; break;
	    }
	}
    }
}

/*
 * Update every object. This time order doesn't matter and we can use the
 * object list.
 */
void
update_objects ()
{
  list_node * it;
  struct object * o;

  for (it = game.cs.objects.begin; it != game.cs.objects.end; it = it->next)
    {
      o = (struct object *)it;

      if (o->dir != STILL && ++o->dsp >= SPS)
        {
          if (MAP_AT (o) == GHOST)
	    {
	      MAP_AT (o) = EMPTY; 
	    }

	  if (o != game.po)
	    {
	       release_buttons (o);
	    }

	  o->off += offset[o->dir];

	  if (o != game.po)
	    {
	      press_buttons (o);
	    }

	  o->dir = STILL;
	  o->dsp = 0;
	}
    }
}

/*
 * Draw all objects. Most objects have only a simple sprite with no alpha
 * channel, but levitators have alpha transparency and a "warp" effect, and the
 * exit is a particle system.
 */
void
draw_objects ()
{
  size_t i, k;

  for (i = 0; i < SIZE; ++i)
    for (k = 0; k < SIZE; ++k)
      {
	draw_column (i, k);
      }
}

void
draw_column (size_t i, size_t k)
{
  size_t j;

  struct object * o;
  SDL_Rect dst;

  for (j = 0; j < SIZE; ++j)
    {
      // If there is a levitator, draw it.
       
      if (game.cs.forces_map[j][i][k] == DIR_UP)
        {
          dst.x = SCREENX (SPS * i, SPS * j, SPS * k);
          dst.y = SCREENY (SPS * i, SPS * j, SPS * k);

          if (game.cs.forces_map[j + 1][i][k] != game.cs.forces_map[j][i][k])
            {
              draw_effect (1, 0, &dst);
            }

          draw_effect (0, 0, &dst);
        }

      // If there is an exit, draw it.

      if (game.cs.forces_map[j][i][k] == WARP)
        {
          dst.x = SCREENX (SPS * i, SPS * j, SPS * k);
          dst.y = SCREENY (SPS * i, SPS * j, SPS * k);
          draw_particles (canvas, &dst);
        }

      // If there is an object, draw it. 
      //
      // FIXME: Note the horribly complicated way to draw moving
      // objects. Order matters a lot and yet, some objects appear in
      // front of others that are adjacent when they ought not to.
       
      if (((o = game.cs.object_map[j][i][k]) && (o->dir == STILL || o->dir == DIR_UP || o->dir == DIR_RT || o->dir == DIR_FT)) 
          || (j > 0 && (o = game.cs.object_map[j - 1][i][k]) && o->dir == DIR_DN)
          || (i > 0 && (o = game.cs.object_map[j][i - 1][k]) && o->dir == DIR_LF)
          || (k > 0 && (o = game.cs.object_map[j][i][k - 1]) && o->dir == DIR_BK))
        {
          Uint32 x = i * SPS;
          Uint32 y = j * SPS;
          Uint32 z = k * SPS;

          switch (o->dir)
            {
            case DIR_LF: x -= o->dsp; break;
            case DIR_RT: x += o->dsp - SPS; break;
            case DIR_DN: y -= o->dsp; break;
            case DIR_UP: y += o->dsp - SPS; break;
            case DIR_BK: z -= o->dsp; break;
            case DIR_FT: z += o->dsp - SPS; break;
            }

          dst.x = SCREENX (x, y, z);
          dst.y = SCREENY (x, y, z);
            
          if (o == game.po)
            {
              if (game.keep_going || game.warped)
                { 
		  draw_object (2, game.cs.cur_ang % 4, &dst); 
		}
            }
          else
            {
              draw_object (o->type & SPRITE, 0, &dst);
            }
        }

      // If there is a feature, draw it.

      else if (game.cs.static_map[j][i][k] & VISIBLE)
        { 
          switch (game.cs.static_map[j][i][k])
            {
            case BELT_LF_1:
            case BELT_FT_1:
            case BELT_RT_1:
            case BELT_BK_1:
              dst.x = SCREENX (SPS * i, SPS * j, SPS * k);
              dst.y = SCREENY (SPS * i, SPS * j, SPS * k);
              draw_object (game.cs.static_map[j][i][k] & SPRITE, 1 + game.cs.ticks % 3, &dst);
              break;

            default:
              dst.x = SCREENX (SPS * i, SPS * j, SPS * k);
              dst.y = SCREENY (SPS * i, SPS * j, SPS * k);
	      draw_object (game.cs.static_map[j][i][k] & SPRITE, 0, &dst);
              break;
            }
        }
    }

  // Apply a 'warp' effect where there are levitators. The entire
  // column is done at once to make the transitions smooth.

  for (j = 0; j < SIZE; ++j)
    {
      if (game.cs.forces_map[j][i][k] == DIR_UP)
        {
          dst.x = SCREENX (SPS * i, SPS * j, SPS * k);
          dst.y = SCREENY (SPS * i, SPS * j, SPS * k);
          warp_surface (canvas, &dst);
        }
    }
}

/*
 * Show level name and other GUI stuff.
 */
void
draw_foreground ()
{
  SDL_Rect dst;
 
  dst.x = (canvas->w - surface_hforhelp->w) / 2;
  dst.y = canvas->h - surface_hforhelp->h;
  SDL_BlitSurface (surface_hforhelp, NULL, canvas, &dst);

  dst.x = (canvas->w - surface_levelname->w) / 2;
  dst.y = 0;
  SDL_BlitSurface (surface_levelname, NULL, canvas, &dst);

  SDL_BlitSurface (surface_frame, NULL, canvas, NULL);
}

/*
 * Handle events and more.
 */
void
handle_player_input ()
{
  SDL_Event event;

  // If we are replaying whe wodox movement is taken from the game.record_list.

  if (game.replay)
    {
      while (game.cs.record_ptr->time == game.cs.ticks)
	{
	  switch (game.cs.record_ptr->key)
	    {
	    case 1: game.keyup = 1; game.must_save = 1; break;
	    case 2: game.keydn = 1; game.must_save = 1; break;
	    case 3: game.keylf = 1; game.must_save = 1; break;
	    case 4: game.keyrt = 1; game.must_save = 1; break;

	    case -1: game.keyup = 0; break;
	    case -2: game.keydn = 0; break;
	    case -3: game.keylf = 0; break;
	    case -4: game.keyrt = 0; break;

	    case 0: PICK_OR_RELEASE (); break;

	    default: break;
	    }
	  ++game.cs.record_ptr;
	}
    }

  // Handle player input.

  while (SDL_PollEvent (&event))
    {
      switch (event.type)
	{
	case SDL_KEYDOWN:
	  switch (event.key.keysym.sym)
	    {
	    case SDLK_UP:	game.keyup = 1; RECORD_MOVE (1); game.must_save = 1; break;
	    case SDLK_DOWN:	game.keydn = 1; RECORD_MOVE (2); game.must_save = 1; break;
	    case SDLK_LEFT:	game.keylf = 1; RECORD_MOVE (3); game.must_save = 1; break;
	    case SDLK_RIGHT:	game.keyrt = 1; RECORD_MOVE (4); game.must_save = 1; break;

	    case SDLK_BACKSPACE:	    
	      load_state (); 
	      RECORD_MOVE (game.keyup ? 1 : -1);
	      RECORD_MOVE (game.keydn ? 2 : -2);
	      RECORD_MOVE (game.keylf ? 3 : -3);
	      RECORD_MOVE (game.keyrt ? 4 : -4);
	      game.po->dir = STILL;
	      break;

	    case SDLK_SPACE:	PICK_OR_RELEASE (); RECORD_MOVE (0); break;

	    case SDLK_F1:	
	      switch (help (str_howtoplay, str_menuplay, "\0rscq"))
	        {
		case 1: game.keep_going = 0; break;
		case 2: game.keep_going = 0; game.keep_playing = 0; game.warped = 1; break;
		case 3: /* load a solution */ break;
		case 4: game.keep_going = 0; game.keep_playing = 0; break;
		}
	      break;

	    case SDLK_p:	freeze (); break;
	    case SDLK_r:	game.keep_going = 0; break;
	    case SDLK_ESCAPE:	game.keep_going = 0; game.keep_playing = 0; break;
	    case SDLK_s:	game.keep_going = 0; game.keep_playing = 0; game.warped = 1; break;
	    default: break;
	    }

	  if (enable_audio && (game.keyup || game.keydn || game.keylf || game.keyrt))
	    {
	      Mix_Resume (CHANNEL_WODOX);
	    }	

	  break;

	case SDL_KEYUP:
	  switch (event.key.keysym.sym)
	    {
	    case SDLK_UP:	game.keyup = 0; RECORD_MOVE (-1); break;
	    case SDLK_DOWN:	game.keydn = 0; RECORD_MOVE (-2); break;
	    case SDLK_LEFT:	game.keylf = 0; RECORD_MOVE (-3); break;
	    case SDLK_RIGHT:	game.keyrt = 0; RECORD_MOVE (-4); break;
	    default: break;
	    }

	  if (enable_audio && (game.keyup | game.keydn | game.keylf | game.keyrt) == 0)
	    {
	      Mix_Pause (CHANNEL_WODOX);
	    }

	  break;

	case SDL_QUIT: exit (0);

	default: break;
	}
    }

  // If the player pushed a button recently and wodox is aligned to the
  // grid and standing on the right kind of tile, save state.

  if (game.must_save && game.po->dsp == 0 && game.po->dir != DIR_DN && FRC_AT (game.po) != DIR_UP)
    {
      switch (MAP_DN (game.po))
	{
	case GROUND:
	case CRATE:
	case BELT_LF_0:
	case BELT_RT_0:
	case BELT_FT_0:
	case BELT_BK_0:
	case BUTTON_0:
	case BUTTON_1:
	case SWITCH_0:
	case SWITCH_1:
  	  save_state ();
	  game.must_save = 0;
	  break;
	}
    }
}

/*
 * Grab an object from the unused list and initialize it.
 */
struct object * 
object_grab (Uint8 type, Uint16 off)
{
  if (list_empty (&game.cs.unused_objects))
    {
      return NULL;
    }

  struct object * o = (struct object *)game.cs.unused_objects.begin;
  list_pop_front (&game.cs.unused_objects);

  memset (o, 0, sizeof (struct object));
  o->type = type;
  o->off = off;
  o->dir = STILL;
  o->dsp = 0;

  return o;
}

/*
 * Drop an object in the unused list.
 *//*
void
object_drop (struct object * o)
{
  list_push_front (&game.cs.unused_objects, (list_node *)o);
}*/

/*
 * Insert object into object list and maps.
 */
void
object_insert (struct object * o)
{
  list_push_back (&game.cs.objects, &(o->node));
  OBJ[o->off] = o;
  MAP[o->off] = o->type;
}

/*
 * Remove object from object list and maps.
 */
void
object_remove (struct object * o)
{
  list_remove (&game.cs.objects, &(o->node));
  OBJ[o->off] = NULL;
  MAP[o->off] = EMPTY;
}

/*
 * Move an object up, pushing every other object on its way if possible.
 */
int
levitate (struct object * o)
{
  struct object * tmp;

  if (Y (o->off) == MAX)
    {
      return 0;
    }

  if ((tmp = OBJ_UP (o)) && tmp->dir == STILL)
    {
      if (levitate (tmp))
	{ 
	  MOVE_UP (o); 
	  return DIR_UP;
	}

      return STILL;
    }

  return TRY_MOVE_UP (o); 
}

/*
 * Release buttons under the chosen object.
 */
void
release_buttons (struct object * o)
{
  switch (MAP_DN (o))
    {
    case BUTTON_1: MAP_DN (o) = BUTTON_0; if (enable_audio) { Mix_PlayChannel (CHANNEL_RELEASE, chunk_release, 0); } break;
    }
}

/*
 * Press buttons under the chosen object.
 */
void
press_buttons (struct object * o)
{
  switch (MAP_DN (o))
    {
    case BUTTON_0: MAP_DN (o) = BUTTON_1; if (enable_audio) { Mix_PlayChannel (CHANNEL_PRESS, chunk_press, 0); } break;
    case SWITCH_0: MAP_DN (o) = SWITCH_1; if (enable_audio) { Mix_PlayChannel (CHANNEL_PRESS, chunk_press, 0); } break; 
    case SWITCH_1: MAP_DN (o) = SWITCH_0; if (enable_audio) { Mix_PlayChannel (CHANNEL_PRESS, chunk_press, 0); } break; 
    }
}

/*
 * Calculate the output of a circuit.
 */
int
calculate (Uint16 * tree, size_t off)
{
  switch (tree[off])
    {
    case NOT:  return !calculate (tree, 2 * off + 1);
    case AND:  return calculate (tree, 2 * off + 1) & calculate (tree, 2 * off + 2);
    case OR:   return calculate (tree, 2 * off + 1) | calculate (tree, 2 * off + 2);
    case XOR:  return calculate (tree, 2 * off + 1) ^ calculate (tree, 2 * off + 2);
    case 0 ... SIZE_3 - 1: return MAP[tree[off]] & ACTIVE ? 1 : 0; 
    }

  return 0;
}

/*
 * Save the state of the level in the state stack.
 */
void
save_state ()
{
  memcpy (game.state_stack_top, &game.cs, sizeof (struct state)); 

  if (++game.state_stack_top == game.state_stack + STATE_STACK_LEN) 
    { 
      game.state_stack_top = game.state_stack; 
    } 

  if (game.state_stack_top == game.state_stack_bottom && ++game.state_stack_bottom == game.state_stack + STATE_STACK_LEN) 
    { 
      game.state_stack_bottom = game.state_stack; 
    } 
}

/*
 * Load the state of the level from the state stack.
 */
void 
load_state ()
{
  if (game.state_stack_top != game.state_stack_bottom)
    {
      if (game.state_stack_top == game.state_stack) 
        { 
          game.state_stack_top = game.state_stack + STATE_STACK_LEN; 
        }
      --game.state_stack_top;
    }

  memcpy (&game.cs, game.state_stack_top, sizeof (struct state)); 
}

/*
 * Some screen transition effects.
 */
void
transition0 (Sint32 x, Sint32 y, int k)
{
  SDL_Rect rect;
  int state;
  int i;

  for (i = 0; i < canvas->w + 32; i += 32)
    {
      state = 2 * k + (i - canvas->w) / 32; 

      if (state > 0)
        {
          rect.x = i - state / 2;
          rect.y = 0;
          rect.w = state;
          rect.h = canvas->h;
          SDL_FillRect (canvas, &rect, 0);
        }
    }
}

void
transition1 (Sint32 x, Sint32 y, int k)
{
  SDL_Rect rect;
  int state;
  int j;

  for (j = 0; j < canvas->h + 32; j += 32)
    {
      state = 2 * k + (j - canvas->h) / 32; 

      if (state > 0)
        {
          rect.x = 0;
          rect.y = j - state / 2;
          rect.w = canvas->w;
          rect.h = state;
          SDL_FillRect (canvas, &rect, 0);
        }
    }
}

void
transition2 (Sint32 x, Sint32 y, int k)
{
  Sint32 i, j;
  Sint32 state;
  Sint16 vx[4];
  Sint16 vy[4];

  for (i= 0; i < canvas->w + 32; i += 32)
    {
      for (j = 0; j < canvas->h + 32; j += 32)
	{
	   state = k - 16 + hypot (i - x, j - y) / 32; 

	   if (state > 0)
            {
              vx[0] = i;
              vx[1] = i + 2 * state;
              vx[2] = i;
              vx[3] = i - 2 * state;
              vy[0] = j + 2 * state;
              vy[1] = j;
              vy[2] = j - 2 * state;
              vy[3] = j;
              filledPolygonRGBA (canvas, vx, vy, 4, 0, 0, 0, 255);
            }
        }
    }
}
